"""
Generic CRUD operations for database entities.

This module provides a set of functions to perform Create, Read, Update,
and Delete operations on database tables, abstracting common SQL patterns.
It relies on a `connect` function from `app.db.db_connection` to establish
database connections and assumes entity objects/classes provide necessary
metadata like `table_name` and data serialization via `to_dict()`.
"""

from app.db.db_connection import connect

def create(obj) -> int:
    """
    Creates a new record in the database based on the provided object.

    The object's 'id' field, if present in its dictionary representation,
    is ignored during insertion, as the ID is expected to be
    auto-generated by the database.

    Args:
        obj: An object instance representing the entity to be created.
             The object must have:
             - A `table_name` attribute (str) specifying the database table.
             - A `to_dict()` method that returns a dictionary of its
               attributes (column_name: value).

    Returns:
        int: The ID of the newly created record, retrieved from the database.
    """
    conn = connect()
    with conn.cursor() as cur:
        data = {key: value for key, value in obj.to_dict().items() if key != "id"}
        column_names = ', '.join(data.keys())
        placeholders = ', '.join(['%s'] * len(data))
        values = tuple(data.values())
        query = f"INSERT INTO {obj.table_name} ({column_names}) VALUES ({placeholders}) RETURNING *"
        cur.execute(query, values)
        result = cur.fetchone()
        conn.commit()
    conn.close()
    return result[0]

def read(cls, **kwargs):
    """
    Retrieves a single record from the database based on the provided filters.

    Args:
        cls: The class representing the entity type to retrieve.
             The class must have a `table_name` attribute (str)
             specifying the database table.
        **kwargs: Keyword arguments where keys are column names and
                  values are the values to filter by.

    Returns:
        tuple | None: A tuple representing the database row if found,
                      otherwise None.
    """
    conn = connect()
    with conn.cursor() as cur:
        # Build the WHERE clause dynamically
        where_clause = ' AND '.join([f"{key} = %s" for key in kwargs])
        values = tuple(kwargs.values())
        query = f"SELECT * FROM {cls.table_name} WHERE {where_clause}"
        cur.execute(query, values)
        result = cur.fetchone()
    conn.close()
    return result

def update(cls, db_id, **kwargs):
    """
    Updates an existing record in the database identified by its ID.

    Args:
        cls: The class representing the entity type to update.
             The class must have a `table_name` attribute (str)
             specifying the database table.
        db_id: The unique identifier (ID) of the record to update.
        **kwargs: Keyword arguments where keys are column names and
                  values are the new values for those columns.
    
    Returns:
        None
    """
    conn = connect()
    with conn.cursor() as cur:
        set_clause = ', '.join([f"{key} = %s" for key in kwargs])
        values = tuple(kwargs.values()) + (db_id,)
        query = f"UPDATE {cls.table_name} SET {set_clause} WHERE id = %s"
        cur.execute(query, values)
        conn.commit()
    conn.close()

def delete(cls, db_id):
    """
    Deletes a record from the database by its ID.

    Args:
        cls: The class representing the entity type from which to delete.
             The class must have a `table_name` attribute (str)
             specifying the database table.
        db_id: The unique identifier (ID) of the record to delete.

    Returns:
        None
    """
    conn = connect()
    with conn.cursor() as cur:
        query = f"DELETE FROM {cls.table_name} WHERE id = %s"
        cur.execute(query, (db_id,))
        conn.commit()
    conn.close()
